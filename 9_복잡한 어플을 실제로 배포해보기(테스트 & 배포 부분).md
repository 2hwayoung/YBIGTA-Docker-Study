# 9. 복잡한 어플을 실제로 배포해보기(테스트 & 배포 부분)

👉 강의: 인프런 - [[따라하며 배우는 도커와 CI환경]](https://www.inflearn.com/course/%EB%94%B0%EB%9D%BC%ED%95%98%EB%A9%B0-%EB%B0%B0%EC%9A%B0%EB%8A%94-%EB%8F%84%EC%BB%A4-ci/dashboard)

👉 발제자: 노연수 (2021.02.17)

---

### 9장 흐름

1. **Github**에 push
2. **Travis CI**
    - 테스트 소스 실행
    - 테스트성공
    - 각각의 Dockerfile 이용하여 이미지 생성(빌드)
    - 이미지 생성 후 Docker Hub으로 전달
3. **Docker Hub**
    - Travis CI에서 빌드된 이미지 보관
    - AWS Elastic Beanstalk에 전달
4. **ElasticBeanStalk**을 통해 배포

---

# 9.1 도커 환경의 MYSQL 부분 정리하기

1. `docker-compose.yml`에서 mysql부분 지워주기

    → mysql 폴더를 지워주는 것과 동일한 효과

2. `db.js`에서 mysql 관련 정보들 AWS에서 DB 생성 후 내용 다시 넣어주기
    - db.js

    ```jsx
    const mysql = require("mysql");
    const pool = mysql.createPool({
        connectionLimit: 10,
        host: process.env.MYSQL_HOST,
        user: process.env.MYSQL_USER,
        password: process.env.MYSQL_ROOT_PASSWORD,
        database: process.env.MYSQL_DATABASE,
        port: process.env.MYSQL_PORT
    });
    exports.pool = pool;
    ```

---

# 9.2 Github에 소스 코드 올리기

1. Github에서 new repository 만들기
2. `.gitignore` 정리
3. 소스 코드 올리기

    ```bash
    $ git init
    $ git add .
    $ git commit -m "first commit"
    $ git remote add origin {레포 주소}
    $ git push origin master
    ```

---

# 9.3 Travis CI Steps

> Travis CI Steps

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled.png)

❗**지난 번 과정과의 차이점**

Docker Hub에서 빌드된 이미지를 보내고 AWS에서 그 이미지를 가져감 

→ EB에서 이미지 빌드할 필요 X (빌드 한 번만!!)

---

# 9.4 .travis.yml 파일 작성하기

> `.travis.yml` 파일 생성

1. Travis CI에게 도커 환경 선언

    ```yaml
    language: generic

    sudo: required

    services:
      - docker
    ```

2. Dockerfile.dev 이용하여 도커 이미지 생성

    ```yaml
    before_install:
      - docker build -t smileajw1004/react-test-app -f ./frontend/Dockerfile.dev ./frontend
    ```

3. 생성된 테스트 이미지 이용하여 테스트 수행

    ```yaml
    script:
      - docker run -e CI=true smileajw1004/react-test-app npm test
    ```

4. 모든 프로젝트의 운영 버전 이미지 빌드
    - 도커 허브에 로그인 (→ Travis CI에 실제 도커 허브 비밀번호와 아이디 집어넣어주기)

        ![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%201.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%201.png)

    - 빌드된 이미지 도커 허브에 Push

    ```yaml
    after_success:
      - docker build -t smileajw1004/docker-frontend ./frontend
      - docker build -t smileajw1004/docker-backend ./backend
      - docker build -t smileajw1004/docker-nginx ./nginx

      - echo "$DOCKER_HUB_PASSWORD" | docker login -u "$DOCKER_HUB_ID" --password-stdin

      - docker push smileajw1004/docker-frontend
      - docker push smileajw1004/docker-backend
      - docker push smileajw1004/docker-nginx
    ```

    - Github에 Push하여 Docker Hub에 잘 올라가는지 확인 (왜 안 올라오지?)

---

# 9.5 Dockerrun.aws.json에 대해서

> `Dockerrun.aws.json`이 필요한 이유

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%202.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%202.png)

- 리액트만을 이용한 앱을 만들 때에는 Dockerfile이 하나
- 따라서 그 도커 파일을 EB에 전달하면 EB가 알아서 빌드된 이미지 돌려 앱 실행 → 설정 필요 X

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%203.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%203.png)

- fullstack 앱에서는 Dockerfile이 여러 개
- EB가 자동으로 프로세스를 해나갈 수 없기 때문에 임의로 설정을 해주어야 한다!

⭐ 그 설정 파일이 바로 `**Dockerrun.aws.json**`

> `Dockerrun.aws.json` 파일이란?

- Docker 컨테이너 세트를 EB 앱으로 배포하는 방법을 설명하는 EB 고유의 json 파일
- 멀티컨테이너 Docker 환경에서 사용 가능
- 각 컨테이너 인스턴스에 배포할 컨테이너 및 탑재할 컨테이너의 호스트 인스턴스에서 생성할 데이터 볼륨을 설명

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%204.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%204.png)

EB가 컨테이너를 어떻게 실행하는지 몰라서 Task에 어떻게 컨테이너를 실행할지 정의 (Task Definition / Container Definition)

- Container Definition을 `Dockerrun.aws.json` 파일에 넣어준다 (→ Docker Daemon으로 전해짐)

❓ **Task Definition(작업 정의)에서 지정할 수 있는 것들?**

-작업의 각 컨테이너에 사용할 도커 이미지

-각 작업 또는 각 컨테이너에서 사용햘 CPU 및 메모리의 양

-해당 작업이 호스팅되는 인프라 결정

-작업의 컨테이너에 사용할 도커 네트워킹 모드

-작업에 사용할 로깅 구성

-컨테이너 종료/실패 시 작업 계속 실행 여부

-컨테이너 시작 시 실행할 명령

-컨테이너에서 사용할 데이터 볼륨

-IAM 역할

---

# 9.6 Dockerrun.aws.json 파일 작성하기

> `Dockerrun.aws.json` 파일 생성하여 Containter Definition 작성

- `AWSEBDockerrunVersion`: Dockerrun 버전
- `containerDefinitions`: 이 안에서 컨테이너들 정의
- 객체 안에서 하나의 컨테이너 정의
    - `name`: 컨테이너 이름
    - `image`: Docker 이미지 이름
    - `hostname`: 호스트 이름. 이 이름을 이용해 도커 컴포즈로 생성된 다른 컨테이너에서 접근 가능
    - `essential`: 컨테이너 실패 시 작업 중지 여부
    - `memory`: 컨테이너 인스턴스에 있는 메모리 양
    - `portmappings`: 컨테이너에 있는 네트워크 지점을 호스트에 있는 지점에 매핑
    - `links`: 연결할 컨테이너의 목록 (nginx에서 frontend, backend로 연결되기 때문)

```json
{
		//Dockerrun 버전 2
    "AWSEBDockerrunVersion": 2,
		// 이 안에서 컨테이너들 정의
    "containerDefinitions": [
				// 객체 안에서 하나의 컨테이너 정의
        {
            "name": "frontend", //컨테이너 이름
            "image": "smileajw1004/docker-frontend", //Docker 이미지 이름
            "hostname": "frontend", // 호스트 이름 (이 이름을 이용해 도커 컴포즈로 생성된 다른 컨테이너에서 접근 가능)
            "essential": false, // 컨테이너 실패 시 작업 중지 여부
            "memory": 128 // 컨테이너 인스턴스에 있는 메모리 양
        },
        {
            "name": "backend",
            "image": "smileajw1004/docker-backend",
            "hostname": "backend",
            "essential": false,
            "memory": 128
        },
        {
            "name": "nginx",
            "image": "smileajw1004/docker-nginx",
            "hostname": "nginx",
            "essential": true,
						// 컨테이너에 있는 네트워크 지점을 호스트에 있는 지점에 매핑
            "portMappings": [
                {
                    "hostPort": 80,
                    "containerPort": 80
                }
            ],
						// 연결할 컨테이너의 목록
            "links": ["frontend", "backend"],
            "memory": 128
        }
    ]
}
```

---

# 9.7 다중 컨테이너 앱을 위한 Elastic beanstalk 환경 생성

> AWS Elastic Beanstalk

1. Create Application
2. 애플리케이션 이름(docker-fullstack-app) 입력
3. 애플리케이션 플랫폼 선택

    -Platform: Docker

    -Platform branch: Multi-container Docker running on 64bit Amazon Linux

    -Platform version: 2.25.0 (Recommended)

4. 애플리케이션 코드 선택 (샘플 애플리케이션)
5. 애플리케이션 생성!

---

# 9.8 VPC(virtual private cloud)와 Security Group 설정하기

> VPC와 Security Group 설정해야 하는 이유

AWS의 RDS를 이용하여 MYSQL을 앱과 연결시키기 위해서

> VPC (Virtual Private Cloud)란?

- VPC를 사용하면 AWS 클라우드에서 논리적으로 격리된 공간을 프로비저닝하여 고객이 정의하는 가상 네트워크에서 AWS 리소스를 시작할 수 있다.
- 내가 만든 인스턴스들을 나의 아이디에서만 접근 가능하도록 격리된 네트워크에서 생성이 되게 해준다.
- EB나 RDS를 생성하면 자동적으로 기본 VPC 할당
- 지역별 할당 → 다른 지역에서는 접근 불가능

✔️ **현재 상황**

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%205.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%205.png)

서로 통신은 할 수 없는 상황! VPC는 EB를 만들 때 자동으로 생성됨

> Security Group(보안 그룹)이란?

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%206.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%206.png)

- Inbound: 외부에서 EC2 인스턴스나 EB 인스턴스로 요청을 보내는 트래픽. HTTP, HTTPS, SSH 등
- Outbound: EC2 인스턴스나 EB 인스턴스 등에서 외부로 나가는 트래픽
- Security Group: Inbound와 Outbound를 통제

> 어떻게 EB와 RDS가 서로 통신할 수 있을까?

❗ 같은 VPC 안에 있는 AWS 서비스 간에는 트래픽을 모두 허용할 수 있게 Security Group을 허용

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%207.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%207.png)

---

# 9.9 MYSQL을 위한 AWS RDS 생성하기

✔️ **`docker-compose.yml`에 DB를 위한 환경변수 넣어주기**

- `docker-compose.yml`

```yaml
backend:
    build: 
      dockerfile: Dockerfile.dev
      context: ./backend
    container_name: app_backend
    volumes:
      - /app/node_modules
      - ./backend:/app
    environment: 
      MYSQL_HOST: mysql
      MYSQL_USER: root 
      MYSQL_ROOT_PASSWORD: johnahn
      MYSQL_DATABASE: myapp
      MYSQL_PORT: 3306
```

- `db.js`

```jsx
const mysql = require("mysql");
const pool = mysql.createPool({
    connectionLimit: 10,
    host: process.env.MYSQL_HOST,
    user: process.env.MYSQL_USER,
    password: process.env.MYSQL_ROOT_PASSWORD,
    database: process.env.MYSQL_DATABASE,
    port: process.env.MYSQL_PORT
});
exports.pool = pool;
```

→ 환경변수 이름을 이용해서 가져와줄 수 있음!

> RDS 생성

1. RDS > 데이터베이스 생성
2. 옵션 선택
3. 위에서 넣은 환경변수 값에 따라 DB 설정 및 DB 옵션 입력
4. 데이터베이스 생성!

---

# 9.10 Security Group 생성하기

> Security Group 생성

1. VPC > 보안그룹 > 보안그룹 생성
2. 기본 세부 정보 입력
3. 보안 그룹 생성
4. 인바운드 규칙 설정 (3306)

---

# 9.11 Security Group 적용하기

> MYSQL 인스턴스에 Security Group 적용

1. RDS > 데이터베이스 > MYSQL 인스턴스 클릭
2. 수정 > 보안 그룹 추가 > 즉시 적용
3. 수정 완료!

> EB 인스턴스에 Security Group 적용

1. EB > 구성 > 인스턴스 편집
2. 새로 생성한 보안 그룹 추가
3. 적용!

👏 **이제 EB와 RDS가 통신 가능 !!**

---

# 9.12 EB와 RDS 소통을 위한 환경 변수 설정하기

아직 EB 안 컨테이너들이 MySQL 인스턴스와 소통할 때 환경변수 부분 인식 X → EB에 환경변수 설정해주기

> 환경 변수 설정

1. EB > 구성 > 소프트웨어 편집
2. 환경변수 설정

    *MYSQL_HOST는 RDS에서 가져오기

---

# 9.13 travis.yml 파일 작성하기 (배포 부분)

> `.travis.yml` 작성

- `provider`: 외부 서비스 표시
- `region`: AWS 서비스가 위치하고 있는 물리적 장소
- `app`: 생성된 앱 이름
- `env`: 환경 이름
- `bucket_name`: 해당 EB를 위한 s3 버킷 이름
- `bucket_path`: 앱 이름과 동일
- `on:`
    - `branch`: 어떤 브랜치에 push할 때 AWS에 배포할 것인가
- `.travis.yml`

```docker
deploy:
  provider: elasticbeanstalk
  region: "us-east-1"
  app: "docker-fullstack-app"
  env: "Dockerfullstackapp-env"
  bucket_name: elasticbeanstalk-us-east-1-955292227972
  bucket_path: "docker-fullstack-app"
  on:
    branch: master
```

---

# 9.14 Travis CI의 AWS 접근을 위한 API key 생성

Travis CI와 AWS가 실질적으로 소통할 수 있도록 인증하는 부분 설정

✔️ (복습) **소스 파일 전달을 위한 접근 요건**

![9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%208.png](9%20%E1%84%87%E1%85%A9%E1%86%A8%E1%84%8C%E1%85%A1%E1%86%B8%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%8B%E1%85%A5%E1%84%91%E1%85%B3%E1%86%AF%E1%84%8B%E1%85%B3%E1%86%AF%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%20%E1%84%87%E1%85%A2%E1%84%91%E1%85%A9%E1%84%92%E1%85%A2%E1%84%87%E1%85%A9%E1%84%80%E1%85%B5(%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20&%20%E1%84%87%20c630a9fbfef1490e979337749124b503/Untitled%208.png)

→ 인증을 위해 API key 필요

> Secret, Access API Key 받기

1. IAM USER 생성
2. API Key를 .travis.yml에 적어주기
    - 비밀 엑세스 키가 외부에 노출되면 안되기 때문에 Travis CI 웹사이트에 적어주고 가져오기
    - `.travis.yml`

    ```yaml
    access_key_id: $AWS_ACCESS_KEY
    secret_access_key: $AWS_SECRET_ACCESS_KEY
    ```

3. 소스 코드 Push
4. EB 링크를 통해 이동